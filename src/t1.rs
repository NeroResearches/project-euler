//! # Идея:
//! Задачу можно решить минимум двумя способами:
//! 1. "В лоб": см. `simple_solution`.
//!    Т.е. просто пробежаться по числам [0; n) и суммировать те, которые делятся либо
//!    на первый делитель, либо на второй.
//! 2. O(1): см. `solve`. Просто формула. Сейчас поясню:
//!    Нам нужны числа, которые делятся либо на d_1,
//!    либо на d_2 (_{n} это индекс, d - divisor), начнем с малого - как найти сумму чисел до `lt`,
//!    которые делятся на `d_1`? Представим ряд таких чисел:
//!    0 , d_1, 0 + 1 * d_1, 0 + 2 * d_1, ..., t * d_1
//!    где `t` - ближайшее число, делящееся на `lt`,
//!    но меньше его, с исключением в виде нуля (см. `nearest_lt`)
//!    Нетрудно увидеть прогрессию (да, я ее специально выделил!) с a1 = 0, a_n = t * d_1
//!    и количеством элементов в ней `n = (a_n / d_1) + 1` (+ 1 значит включая ноль, см. пояснение 1)
//!    Перед тем, как попытаться сложить эти две суммы, стоит уточнить, что некоторые числа посчитаны дважды:
//!    например, возьмем такой пример из условия (3 и 5 до 16и): [0, 3, 5, 6, 9, 10, 12, 15]
//!    числа, которые делятся на 3: [0, 3, 6, 9, 12, 15]
//!                              5: [0, 5, 10, 15]
//!    Здесь мы дважды посчитали число 15, так как оно одновременно делится и на 3, и на 5 (см. пояснение 2),
//!    а значит нужно вычесть эти дважды посчитанные числа с помощью той же операции, но делителем будет выступать
//!    уже `d_1 * d_2` (или шагом для прогрессии, если угодно)
//!    таким образом, если представить, что s_1 - сумма чисел, меньше `lt`,
//!    которые делятся на d_1, а s_2 - сумма на d_2, а s_3 так же до d_1 * d_2, то результатом будет:
//!    s_1 + s_2 - s_3
//!
//! # Пояснения
//!
//! 1. Можно доказать двумя путями - решения простого уравнения прогрессии, или обыкновенная логика.
//!    первый способ предоставлю для читателя, так как он требует каких-то вычислений и конкретно
//!    я первым делом подумал о втором, это просто одно и то же, но сказанное разным языком.
//!    
//!    Конечное значение этой прогрессии(t) - ближайшее число к `lt`, которое делится
//!    на `d_1` и меньше его (опять же, и исключением в виде нуля), а значит его можно разложить таким образом:
//!    t * d_1, напомню формулу n'ого члена прогрессии (с поправкой на a1 = 0): d_1 * (n - 1),
//!    t здесь можно рассматривать как замену t = (n - 1), а значит при решении уравнения надо будет раскрыть
//!    t, чтобы узнать n (количество элементов в прогрессии). Сказал как будто рассматриваю первый способ,
//!    но в реальности достаточно просто понимать, что при делении мы получим номер в ряду не включая ноль, а значит
//!    ноль надо включить самостоятельно, прибавив единицу к номеру.
//! 2. Умножение очень удобно представлять в виде множества чисел, например, 10 это {2, 5},
//!    а 13 это {13} (исключая нейтральный элемент, в данном случае единицу),
//!    умножение - как объединение этих множеств, а деление, как исключение из них:
//!    6 * 4 = 24,
//!    6: {3, 2}
//!    4: {2, 2}
//!    24: {3, 2, 2, 2}
//!    24 делится одновременно и на 6, и на 4, так как из множества можно исключить числа {3, 2} и {2, 2}
//!    
//!    Представим множество D_1 - это множество простых делителей d_1 и
//!    множество D_2 - множество простых делителей d_2,
//!    D_1 | D_2 = d_1 * d_2 (| - объединение множеств)
//!    а теперь ближе к теме: представим число a(множество делителей - A),
//!    умножение на наш результат будет эквивалентным такому выражению: A | D_1 | D_2,
//!    получившееся число, назовем его a'(множество A'), делится на d_1 и на d_2, так как из множества
//!    A' можно исключить элементы D_1 и D_2.
//!
//!    Объяснение не должно было быть таким сложным (или... Подробным? Не назвал бы это сложным чем-то
//!    скорее эту писанину можно назвать тратой времени), это просто интуитивно понятно, что число
//!    умноженное на некое d_1 * d_2 будет делится и на d_1 и на d_2, если только Вы всю школьную
//!    математику не пропустили. Наверное, это написано здесь больше для меня, упражнение в строгости (наверное).

type Int = u32;

#[allow(unused)]
fn simple_solution(div1: Int, div2: Int, lt: Int) -> Int {
    (0..lt)
        .filter(|&value| ((value % div1) == 0) || ((value % div2) == 0))
        .sum()
}

/// Обыкновенная сумма `n` членов арифметической прогрессии
fn progression_sum(start: Int, end: Int, n: Int) -> Int {
    // `>> 1` здесь используется вместо деления на 2
    ((start + end) * n) >> 1
}

/// Вернуть ближайшее меньшее число, которые делится на `div`.
/// С одним исключением - если `lt == 0`, то результат будет равен нулю
fn nearest_lt(lt: Int, div: Int) -> Int {
    let rem = lt % div;
    let result = lt - rem;
    if result == lt {
        lt.checked_sub(div).unwrap_or(0)
    } else {
        result
    }
}

fn sum_of_divisables(lt: Int, div: Int) -> Int {
    let nearest = nearest_lt(lt, div);

    // решил не выносить +-1, так как это просто логично,
    // а обзывать переменную чем-то типа n_in_series_excluding_zero - слишком длинно
    let n_in_series = (nearest / div) + 1;
    let end = div * (n_in_series - 1);

    progression_sum(0, end, n_in_series)
}

/// # Задача
///
/// Если выписать все натуральные числа меньше 10, кратные 3 или 5, то получим 3, 5, 6 и 9.
/// Сумма этих чисел равна 23.
/// Найдите сумму всех чисел меньше 1000, кратных 3 или 5.
pub fn solve(div1: Int, div2: Int, lt: Int) -> Int {
    let overlapped_div = div1 * div2;
    assert_ne!(overlapped_div, 0);

    let div1_sum = sum_of_divisables(lt, div1);
    let div2_sum = sum_of_divisables(lt, div2);
    let overlapped_sum = sum_of_divisables(lt, overlapped_div);

    div1_sum + div2_sum - overlapped_sum
}

#[cfg(test)]
mod tests {
    use super::{solve, Int};
    use rstest::rstest;

    #[rstest]
    #[case(3, 5, 10, 23)]
    #[case(2, 3, 9, 23)]
    #[case(3, 5, 1000, 233168)]
    fn test_solution(
        #[case] div1: Int,
        #[case] div2: Int,
        #[case] lt: Int,
        #[case] should_be: Int,
    ) {
        let result = solve(div1, div2, lt);
        assert_eq!(result, should_be);
    }
}
